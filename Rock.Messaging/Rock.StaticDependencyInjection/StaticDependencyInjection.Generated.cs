//////////////////////////////////////////////////////////////////////////////////////
//                                                                                  //
// This file was generated by a tool. It would be a bad idea to make changes to it. //
//                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

namespace Rock.Messaging.Rock.StaticDependencyInjection
{
    internal sealed partial class CompositionRoot : CompositionRootBase
    {
        internal CompositionRoot()
        {
        }
    }

    internal abstract class CompositionRootBase
    {
        private readonly ConcurrentDictionary<Tuple<string, bool>, ICollection<Type>> _candidateTypesCache;
        private readonly ConcurrentDictionary<string, ConcurrentDictionary<Tuple<string, string, bool, bool>, IEnumerable<string>>> _candidateTypeNamesByTargetTypeNameCache;

        protected CompositionRootBase()
        {
            _candidateTypesCache = new ConcurrentDictionary<Tuple<string, bool>, ICollection<Type>>();
            _candidateTypeNamesByTargetTypeNameCache = new ConcurrentDictionary<string, ConcurrentDictionary<Tuple<string, string, bool, bool>, IEnumerable<string>>>();
        }

        /// <summary>
        /// Import the types for this library by calling one of the import methods:
        /// <see cref="ImportSingle{TTargetType}"/>, <see cref="ImportSingle{TTargetType,TFactoryType}"/>,
        /// <see cref="ImportFirst{TTargetType}"/>, <see cref="ImportFirst{TTargetType,TFactoryType}"/>,
        /// <see cref="ImportMultiple{TTargetType}"/>, or <see cref="ImportMultiple{TTargetType, TFactoryType}"/>.
        /// </summary>
        public abstract void Bootstrap();

        /// <summary>
        /// Gets a value indicating whether static dependency injection is enabled.
        /// </summary>
        public virtual bool IsEnabled
        {
            get { return true; }
        }

        /// <summary>
        /// Return a collection of metadata objects that describe the export operations for a type.
        /// </summary>
        /// <param name="type">The type to get export metadata.</param>
        /// <returns>A collection of metadata objects that describe export operations.</returns>
        protected virtual IEnumerable<ExportInfo> GetExportInfos(Type type)
        {
            yield return new ExportInfo(type);
        }

        /// <summary>
        /// Return an object that defines various options.
        /// </summary>
        protected virtual ImportOptions GetDefaultImportOptions()
        {
            return new ImportOptions();
        }

        /// <summary>
        /// Imports the type specified by <typeparamref name="TTargetType"/>. When a single
        /// class with a public parameterless constructor is found that implements or
        /// inherits from <typeparamref name="TTargetType"/>, then an instance of that class 
        /// will be created and passed to the <paramref name="importAction"/> parameter callback.
        /// </summary>
        /// <typeparam name="TTargetType">
        /// The type to import. An object of this type will be passed to the 
        /// <paramref name="importAction"/> parameter callback.
        /// </typeparam>
        /// <param name="importAction">
        /// A callback function to invoke when an implementation of
        ///  <typeparamref name="TTargetType"/> is created.
        /// </param>
        /// <param name="importName">
        /// The name of this import operation. If not null, exported classes without 
        /// a matching name are excluded.
        /// </param>
        /// <param name="options">
        /// The import options to use. If null or not provided, the value returned by 
        /// <see cref="GetDefaultImportOptions"/> is returned.
        /// </param>
        protected void ImportSingle<TTargetType>(
            Action<TTargetType> importAction,
            string importName = null,
            ImportOptions options = null)
            where TTargetType : class
        {
            ImportSingleType(
                importAction,
                GetImportInfo<TTargetType>(importName, options),
                CreateInstance<TTargetType>);
        }

        /// <summary>
        /// Imports the type specified by <typeparamref name="TTargetType"/>. When a single
        /// class with a public parameterless constructor is found that implements or
        /// inherits from either <typeparamref name="TTargetType"/> or
        /// <typeparamref name="TFactoryType"/>, then an instance of that class is created. 
        /// If that instance is a <typeparamref name="TTargetType"/>, than that instance will be
        /// passed to the <paramref name="importAction"/> callback. If the instance is a
        /// <typeparamref name="TFactoryType"/>, then an instance of
        /// <typeparamref name="TTargetType"/> is obtained by using the 
        /// <paramref name="getTarget"/> function and passed to the 
        /// <paramref name="importAction"/> callback.
        /// </summary>
        /// <typeparam name="TTargetType">
        /// The type to import. An object of this type will be passed to the 
        /// <paramref name="importAction"/> parameter callback.
        /// </typeparam>
        /// <typeparam name="TFactoryType">
        /// A type that exposes a method or property that can be invoked to obtain an instance 
        /// of <typeparamref name="TTargetType"/>.
        /// </typeparam>
        /// <param name="importAction">
        /// A callback function to invoke when an implementation of <typeparamref name="TTargetType"/> is created.
        /// </param>
        /// <param name="getTarget">
        /// A function used to obtain an instance of <typeparamref name="TTargetType"/>
        /// by using an instance of <typeparamref name="TFactoryType"/>.
        /// </param>
        /// <param name="importName">
        /// The name of this import operation. If not null, exported classes without a matching name are excluded.
        /// </param>
        /// <param name="options">
        /// The import options to use. If null or not provided, the value returned by 
        /// <see cref="GetDefaultImportOptions"/> is returned.
        /// </param>
        protected void ImportSingle<TTargetType, TFactoryType>(
            Action<TTargetType> importAction,
            Func<TFactoryType, TTargetType> getTarget,
            string importName = null,
            ImportOptions options = null)
            where TTargetType : class
            where TFactoryType : class
        {
            ImportSingleType(
                importAction,
                GetImportInfo<TTargetType>(importName, options, typeof(TFactoryType)),
                t => CreateInstance(t, getTarget));
        }

        /// <summary>
        /// Imports the type specified by <typeparamref name="TTargetType"/>. When any class
        /// with a public parameterless constructor is found that implements or inherits from
        /// <typeparamref name="TTargetType"/>, then the one with the highest priority will be
        /// created and passed to the <paramref name="importAction"/> parameter callback.
        /// </summary>
        /// <typeparam name="TTargetType">
        /// The type to import. An object of this type will be passed to the 
        /// <paramref name="importAction"/> parameter callback.
        /// </typeparam>
        /// <param name="importAction">
        /// A callback function to invoke when an implementation of <typeparamref name="TTargetType"/> is created.
        /// </param>
        /// <param name="importName">
        /// The name of this import operation. If not null, exported classes without a matching name are excluded.
        /// </param>
        /// <param name="options">
        /// The import options to use. If null or not provided, the value returned by 
        /// <see cref="GetDefaultImportOptions"/> is returned.
        /// </param>
        protected void ImportFirst<TTargetType>(
            Action<TTargetType> importAction,
            string importName = null,
            ImportOptions options = null)
            where TTargetType : class
        {
            ImportFirstType(
                importAction,
                GetInstances<TTargetType>(importName, options));
        }

        /// <summary>
        /// Imports the type specified by <typeparamref name="TTargetType"/>. When any
        /// class with a public parameterless constructor is found that implements or
        /// inherits from either <typeparamref name="TTargetType"/> or
        /// <typeparamref name="TFactoryType"/>, then an instance of the highest priority
        /// class is created. If that instance is a <typeparamref name="TTargetType"/>, than that 
        /// instance will be passed to the <paramref name="importAction"/> callback. If the 
        /// instance is a <typeparamref name="TFactoryType"/>, then an instance of
        /// <typeparamref name="TTargetType"/> is obtained by using the 
        /// <paramref name="getTarget"/> function and passed to the 
        /// <paramref name="importAction"/> callback.
        /// </summary>
        /// <typeparam name="TTargetType">
        /// The type to import. An object of this type will be passed to the 
        /// <paramref name="importAction"/> parameter callback.
        /// </typeparam>
        /// <typeparam name="TFactoryType">
        /// A type that exposes a method or property that can be invoked to obtain an instance 
        /// of <typeparamref name="TTargetType"/>.
        /// </typeparam>
        /// <param name="importAction">
        /// A callback function to invoke when an implementation of <typeparamref name="TTargetType"/> is created.
        /// </param>
        /// <param name="getTarget">
        /// A function used to obtain an instance of <typeparamref name="TTargetType"/>
        /// by using an instance of <typeparamref name="TFactoryType"/>.
        /// </param>
        /// <param name="importName">
        /// The name of this import operation. If not null, exported classes without a matching name are excluded.
        /// </param>
        /// <param name="options">
        /// The import options to use. If null or not provided, the value returned by 
        /// <see cref="GetDefaultImportOptions"/> is returned.
        /// </param>
        protected void ImportFirst<TTargetType, TFactoryType>(
            Action<TTargetType> importAction,
            Func<TFactoryType, TTargetType> getTarget,
            string importName = null,
            ImportOptions options = null)
            where TTargetType : class
            where TFactoryType : class
        {
            ImportFirstType(
                importAction,
                GetInstances(getTarget, importName, options));
        }

        /// <summary>
        /// Imports the type specified by <typeparamref name="TTargetType"/> for many
        /// implementations. When zero to many classes with a public parameterless 
        /// constructor are found that implements or inherits from 
        /// <typeparamref name="TTargetType"/>, then an instances of those class will be 
        /// created and passed to the <paramref name="importAction"/> parameter callback.
        /// </summary>
        /// <typeparam name="TTargetType">
        /// The type to import. Objects of this type will be passed to the 
        /// <paramref name="importAction"/> parameter callback.
        /// </typeparam>
        /// <param name="importAction">
        /// A callback function to invoke when a implementations of 
        /// <typeparamref name="TTargetType"/> are created.
        /// </param>
        /// <param name="importName">
        /// The name of this import operation. If not null, exported classes without a matching name are excluded.
        /// </param>
        /// <param name="options">
        /// The import options to use. If null or not provided, the value returned by 
        /// <see cref="GetDefaultImportOptions"/> is returned.
        /// </param>
        protected void ImportMultiple<TTargetType>(
            Action<IEnumerable<TTargetType>> importAction,
            string importName = null,
            ImportOptions options = null)
            where TTargetType : class
        {
            importAction(GetInstances<TTargetType>(importName, options).ToList());
        }

        /// <summary>
        /// Imports the type specified by <typeparamref name="TTargetType"/> for many 
        /// implementations. When zero to many classes with a public parameterless 
        /// constructor are found that implements or inherits from either 
        /// <typeparamref name="TTargetType"/> or <typeparamref name="TFactoryType"/>, 
        /// then instances of those classes are created. If an instance is a 
        /// <typeparamref name="TTargetType"/>, than that instance will be passed as part of a 
        /// collection to the <paramref name="importAction"/> callback. If an instance is a
        /// <typeparamref name="TFactoryType"/>, then an instance of
        /// <typeparamref name="TTargetType"/> is obtained by using the 
        /// <paramref name="getTarget"/> function and passed to the 
        /// <paramref name="importAction"/> callback.
        /// </summary>
        /// <typeparam name="TTargetType">
        /// The type to import. Objects of this type will be passed to the 
        /// <paramref name="importAction"/> parameter callback.
        /// </typeparam>
        /// <typeparam name="TFactoryType">
        /// A type that exposes a method or property that can be invoked to obtain an instance 
        /// of <typeparamref name="TTargetType"/>.
        /// </typeparam>
        /// <param name="importAction">
        /// A callback function to invoke when a implementations of 
        /// <typeparamref name="TTargetType"/> are created.
        /// </param>
        /// <param name="getTarget">
        /// A function used to obtain an instance of <typeparamref name="TTargetType"/>
        /// by using an instance of <typeparamref name="TFactoryType"/>.
        /// </param>
        /// <param name="importName">
        /// The name of this import operation. If not null, exported classes without a matching name are excluded.
        /// </param>
        /// <param name="options">
        /// The import options to use. If null or not provided, the value returned by 
        /// <see cref="GetDefaultImportOptions"/> is returned.
        /// </param>
        protected void ImportMultiple<TTargetType, TFactoryType>(
            Action<IEnumerable<TTargetType>> importAction,
            Func<TFactoryType, TTargetType> getTarget,
            string importName = null,
            ImportOptions options = null)
            where TTargetType : class
            where TFactoryType : class
        {
            importAction(GetInstances(getTarget, importName, options).ToList());
        }

        private IEnumerable<TTargetType> GetInstances<TTargetType>(
            string importName,
            ImportOptions options)
            where TTargetType : class
        {
            return GetInstances(
                GetImportInfo<TTargetType>(importName, options),
                CreateInstance<TTargetType>);
        }

        private IEnumerable<TTargetType> GetInstances<TTargetType, TFactoryType>(
            Func<TFactoryType, TTargetType> getTarget,
            string importName,
            ImportOptions options)
            where TTargetType : class
            where TFactoryType : class
        {
            return GetInstances(
                GetImportInfo<TTargetType>(
                    importName,
                    options,
                    typeof(TFactoryType)),
                type => CreateInstance(type, getTarget));
        }

        private ImportInfo GetImportInfo<TTargetType>(
            string importName,
            ImportOptions options,
            Type factoryType = null)
            where TTargetType : class
        {
            return new ImportInfo(
                importName,
                typeof(TTargetType),
                factoryType,
                options ?? GetDefaultImportOptions());
        }

        private void ImportSingleType<TTargetType>(
            Action<TTargetType> importAction,
            ImportInfo import,
            Func<Type, TTargetType> createInstance)
            where TTargetType : class
        {
            var candidateTypeNames = GetCandidateTypeNames(import);

            var instance =
                GetPrioritizedGroupsOfCandidateTypes(candidateTypeNames, import)
                    .Select(candidateTypes => ChooseCandidateType(candidateTypes, import))
                    .Select(t => t == null ? null : createInstance(t))
                    .FirstOrDefault();

            if (instance != null)
            {
                importAction(instance);
            }
        }

        private static void ImportFirstType<TTargetType>(
            Action<TTargetType> importAction,
            IEnumerable<TTargetType> instances)
            where TTargetType : class
        {
            var instance = instances.FirstOrDefault();

            if (instance != null)
            {
                importAction(instance);
            }
        }

        private IEnumerable<TTargetType> GetInstances<TTargetType>(
            ImportInfo import,
            Func<Type, TTargetType> createInstance)
            where TTargetType : class
        {
            var candidateTypeNames = GetCandidateTypeNames(import);

            var prioritizedGroupsOfCandidateTypes =
                GetPrioritizedGroupsOfCandidateTypes(
                    candidateTypeNames,
                    import);

            return (
                from candidateTypes in prioritizedGroupsOfCandidateTypes
                from candidateType in candidateTypes
                select createInstance(candidateType))
                .Where(instance => instance != null);
        }

        private static TTargetType CreateInstance<TTargetType>(Type candidateType)
            where TTargetType : class
        {
            try
            {
                var instance = Instantiate(candidateType);

                var target = instance as TTargetType;
                if (target != null)
                {
                    return target;
                }

                return null;
            }
            catch
            {
                return null;
            }
        }

        private static TTargetType CreateInstance<TTargetType, TFactoryType>(
            Type candidateType,
            Func<TFactoryType, TTargetType> getTarget)
            where TTargetType : class
            where TFactoryType : class
        {
            try
            {
                var instance = Instantiate(candidateType);

                var factory = instance as TFactoryType;
                if (factory != null)
                {
                    return getTarget(factory);
                }

                var target = instance as TTargetType;
                if (target != null)
                {
                    return target;
                }

                return null;
            }
            catch
            {
                return null;
            }
        }

        private static object Instantiate(Type candidateType)
        {
            if (candidateType.GetConstructor(Type.EmptyTypes) != null)
            {
                return Activator.CreateInstance(candidateType);
            }

            var ctor =
                candidateType.GetConstructors()
                    .OrderByDescending(c => c.GetParameters().Length)
                    .First(c => c.GetParameters().All(HasDefaultValue));

            var args = ctor.GetParameters().Select(p => p.DefaultValue).ToArray();

            return Activator.CreateInstance(candidateType, args);
        }

        private IEnumerable<IList<Type>> GetPrioritizedGroupsOfCandidateTypes(
            IEnumerable<string> candidateTypeNames,
            ImportInfo import)
        {
            Func<Type, bool> isPreferredType;

            if (import.FactoryType == null)
            {
                isPreferredType = type => false;
            }
            else
            {
                if (import.Options.PreferTTargetType)
                {
                    isPreferredType = GetIsTargetTypeFunc(import.TargetType, import.Options.AllowNonPublicClasses);
                }
                else
                {
                    isPreferredType = GetIsTargetTypeFunc(import.FactoryType, import.Options.AllowNonPublicClasses);
                }
            }

            var prioritizedGroupsOfCandidateTypes =
                candidateTypeNames.SelectMany(GetExportInfos)
                    .Where(export =>
                        export != null
                        && !export.Disabled
                        && AreCompatible(import, export))
                    .GroupBy(x => x.Priority)
                    .OrderByDescending(g => g.Key)
                    .Select(g =>
                        g.OrderByDescending(export => isPreferredType(export.TargetClass))
                            .ThenBy(export => export, import.Options.ExportComparer)
                            .ToList())
                    .ToList();

            var uniqueExports = new List<ExportInfo>();
            var groupsToRemove = new List<List<ExportInfo>>();

            foreach (var group in prioritizedGroupsOfCandidateTypes)
            {
                var exportsToRemove = new List<ExportInfo>();

                foreach (var export in group)
                {
                    if (uniqueExports.Any(uniqueExport =>
                        export.TargetClass == uniqueExport.TargetClass
                        && export.Name == uniqueExport.Name))
                    {
                        exportsToRemove.Add(export);
                    }
                    else
                    {
                        uniqueExports.Add(export);
                    }
                }

                foreach (var export in exportsToRemove)
                {
                    group.Remove(export);
                }

                if (group.Count == 0)
                {
                    groupsToRemove.Add(group);
                }
            }

            foreach (var group in groupsToRemove)
            {
                prioritizedGroupsOfCandidateTypes.Remove(group);
            }

            return
                prioritizedGroupsOfCandidateTypes
                    .Select(group => group.Select(g => g.TargetClass).ToList()).ToList();
        }

        private static bool AreCompatible(ImportInfo import, ExportInfo export)
        {
            if (!import.Options.IncludeNamedExportsFromUnnamedImports
                && export.Name != null
                && import.Name == null)
            {
                return false;
            }

            return export.Name == import.Name || import.Name == null;
        }

        private static Type ChooseCandidateType(
            IList<Type> candidateTypes,
            ImportInfo import)
        {
            if (candidateTypes.Count == 1)
            {
                return candidateTypes[0];
            }

            if (import.FactoryType != null)
            {
                var data =
                    candidateTypes.Select(type =>
                    {
                        var interfaces = type.GetInterfaces();

                        return new
                        {
                            Type = type,
                            IsTarget = interfaces.Any(i => i.AssemblyQualifiedName == import.TargetTypeName),
                            IsFactory = interfaces.Any(i => i.AssemblyQualifiedName == import.FactoryTypeName)
                        };
                    }).ToList();

                if (import.Options.PreferTTargetType)
                {
                    if ((data.Count(x => x.IsTarget) == 1)
                        && (data.Count(x => x.IsFactory && !x.IsTarget) == (data.Count - 1)))
                    {
                        return data.Single(x => x.IsTarget).Type;
                    }
                }
                else
                {
                    if ((data.Count(x => x.IsFactory) == 1)
                        && (data.Count(x => x.IsTarget && !x.IsFactory) == (data.Count - 1)))
                    {
                        return data.Single(x => x.IsFactory).Type;
                    }
                }
            }

            return null;
        }

        private IEnumerable<ExportInfo> GetExportInfos(string assemblyQualifiedName)
        {
            try
            {
                var type = Type.GetType(assemblyQualifiedName);

                if (type == null)
                {
                    return null;
                }

                return GetExportInfos(type);
            }
            catch
            {
                return null;
            }
        }

        private IEnumerable<string> GetCandidateTypeNames(ImportInfo import)
        {
            var candidateTypeNamesCache =
                _candidateTypeNamesByTargetTypeNameCache.GetOrAdd(
                    import.TargetTypeName,
                    _ => new ConcurrentDictionary<Tuple<string, string, bool, bool>, IEnumerable<string>>());

            var key = Tuple.Create(
                import.TargetTypeName,
                import.FactoryTypeName,
                import.Options.AllowNonPublicClasses,
                import.Options.IncludeTypesFromThisAssembly);

            var candidateTypeNames =
                candidateTypeNamesCache.GetOrAdd(
                    key,
                    _ =>
                    {
                        var isTargetType = GetIsTargetTypeFunc(import.TargetType, import.Options.AllowNonPublicClasses);

                        if (import.FactoryType != null)
                        {
                            var isFactoryType = GetIsTargetTypeFunc(import.FactoryType, import.Options.AllowNonPublicClasses);
                            var isTargetTypeLocal = isTargetType;

                            isTargetType = type => isTargetTypeLocal(type) || isFactoryType(type);
                        }

                        var candidateTypes =
                            _candidateTypesCache.GetOrAdd(
                                Tuple.Create(string.Join("|", import.Options.DirectoryPaths), import.Options.IncludeTypesFromThisAssembly),
                                __ => GetCandidateTypes(import.Options.DirectoryPaths, import.Options.IncludeTypesFromThisAssembly));

                        return
                            candidateTypes
                                .Where(isTargetType)
                                .Select(t => t.AssemblyQualifiedName)
                                .ToList();
                    });

            return candidateTypeNames;
        }

        private static Func<Type, bool> GetIsTargetTypeFunc(Type targetType, bool allowNonPublicClasses)
        {
            var targetTypeName = targetType.AssemblyQualifiedName;

            if (targetTypeName == null)
            {
                return typeInQuestion => false;
            }

            if (targetType.IsInterface)
            {
                return typeInQuestion =>
                    (typeInQuestion.IsPublic || allowNonPublicClasses)
                    && typeInQuestion.GetInterfaces().Any(i => i.AssemblyQualifiedName == targetTypeName);
            }

            if (targetType.IsClass && !targetType.IsSealed)
            {
                return typeInQuestion =>
                {
                    var type = typeInQuestion;

                    while (type != null)
                    {
                        if (type.AssemblyQualifiedName == targetTypeName)
                        {
                            return true;
                        }

                        type = type.BaseType;
                    }

                    return false;
                };
            }

            return typeInQuestion => false;
        }

        private ICollection<Type> GetCandidateTypes(IEnumerable<string> directoryPaths, bool includeTypesFromThisAssembly)
        {
            try
            {
                AppDomain.CurrentDomain.ReflectionOnlyAssemblyResolve += AppDomainOnReflectionOnlyAssemblyResolve;
                return GetAssemblyFiles(directoryPaths, includeTypesFromThisAssembly).SelectMany(x => LoadCandidateTypes(x, includeTypesFromThisAssembly)).ToList();
            }
            finally
            {
                AppDomain.CurrentDomain.ReflectionOnlyAssemblyResolve -= AppDomainOnReflectionOnlyAssemblyResolve;
            }
        }

        private static Assembly AppDomainOnReflectionOnlyAssemblyResolve(object sender, ResolveEventArgs args)
        {
            return Assembly.ReflectionOnlyLoad(args.Name);
        }

        private static IEnumerable<string> GetAssemblyFiles(IEnumerable<string> directoryPaths, bool includeTypesFromThisAssembly)
        {
            foreach (var directoryPath in directoryPaths)
            {
                if (!Directory.Exists(directoryPath))
                {
                    continue;
                }

                IEnumerable<string> dllFiles;

                try
                {
                    dllFiles = Directory.EnumerateFiles(directoryPath, "*.dll");
                }
                catch
                {
                    dllFiles = Enumerable.Empty<string>();
                }

                IEnumerable<string> exeFiles;

                try
                {
                    exeFiles = Directory.EnumerateFiles(directoryPath, "*.exe");
                }
                catch
                {
                    exeFiles = Enumerable.Empty<string>();
                }

                foreach (var file in dllFiles.Concat(exeFiles))
                {
                    yield return file;
                }
            }
        }

        private static IEnumerable<Type> LoadCandidateTypes(string assemblyFile, bool includeTypesFromThisAssembly)
        {
            try
            {
                var assembly = Assembly.ReflectionOnlyLoadFrom(assemblyFile);

                if (!includeTypesFromThisAssembly
                    && assembly.FullName == typeof(CompositionRootBase).Assembly.FullName)
                {
                    return Enumerable.Empty<Type>();
                }

                return
                    GetTypesSafely(assembly)
                        .Where(t =>
                            t.IsClass
                            && !t.IsAbstract
                            && t.AssemblyQualifiedName != null
                            && HasDefaultishConstructor(t));
            }
            catch
            {
                return Enumerable.Empty<Type>();
            }
        }

        private static IEnumerable<Type> GetTypesSafely(Assembly assembly)
        {
            try
            {
                return assembly.GetTypes();
            }
            catch (ReflectionTypeLoadException ex)
            {
                return ex.Types.Where(t => t != null);
            }
        }

        private static bool HasDefaultishConstructor(Type type)
        {
            try
            {
                return
                    type.GetConstructor(Type.EmptyTypes) != null
                    || type.GetConstructors().Any(ctor => ctor.GetParameters().All(HasDefaultValue));
            }
            catch
            {
                return false;
            }
        }

        private static bool HasDefaultValue(ParameterInfo parameter)
        {
            const ParameterAttributes hasDefaultValue =
                ParameterAttributes.HasDefault | ParameterAttributes.Optional;

            return (parameter.Attributes & hasDefaultValue) == hasDefaultValue;
        }

        private class ImportInfo
        {
            private readonly string _name;
            private readonly Type _targetType;
            private readonly Type _factoryType;
            private readonly ImportOptions _options;

            public ImportInfo(
                string name,
                Type targetType,
                Type factoryType,
                ImportOptions options)
            {
                _name = name;
                _targetType = targetType;
                _factoryType = factoryType;
                _options = options;
            }

            internal string Name { get { return _name; } }
            internal Type TargetType { get { return _targetType; } }
            internal Type FactoryType { get { return _factoryType; } }
            internal ImportOptions Options { get { return _options; } }

            internal string TargetTypeName
            {
                get
                {
                    return TargetType.AssemblyQualifiedName;
                }
            }

            internal string FactoryTypeName
            {
                get
                {
                    return
                        _factoryType == null
                            ? null
                            : _factoryType.AssemblyQualifiedName;
                }
            }
        }
    }

    /// <summary>
    /// An internal helper class that makes it easier for your library to implement
    /// the static default pattern that Rock.StaticDependencyInjection is meant to
    /// support.
    /// </summary>
    /// <typeparam name="T">A type that requires a default instance.</typeparam>
    internal sealed class Default<T>
    {
        private readonly Lazy<T> _defaultInstance;
        private Lazy<T> _currentInstance;

        /// <summary>
        /// Initializes a new instance of the <see cref="Default{T}"/> class.
        /// </summary>
        /// <param name="createDefaultInstance">
        /// A function that describes how to create the the object returned by the
        /// <see cref="DefaultInstance"/> property.
        /// </param>
        public Default(Func<T> createDefaultInstance)
        {
            _defaultInstance = new Lazy<T>(createDefaultInstance);
            _currentInstance = _defaultInstance;
        }

        /// <summary>
        /// Gets the default instance of <typeparamref name="T"/>. This value is 
        /// returned by the <see cref="Current"/> property when neither the
        /// <see cref="SetCurrent(System.Func{T})"/> nor <see cref="SetCurrent(T)"/>
        /// has been called.
        /// </summary>
        public T DefaultInstance
        {
            get { return _defaultInstance.Value; }
        }

        /// <summary>
        /// Gets the current value for an instance of type <typeparamref name="T"/>.
        /// </summary>
        public T Current
        {
            get { return _currentInstance.Value; }
        }

        /// <summary>
        /// Restores the value of the <see cref="Current"/> property to the value of
        /// the <see cref="DefaultInstance"/> property.
        /// </summary>
        public void RestoreDefault()
        {
            SetCurrent(null);
        }

        /// <summary>
        /// Sets the value of the <see cref="Current"/> property. If the
        /// <paramref name="getInstance"/> parameter is null, sets the value of the
        /// <see cref="Current"/> to the value of the <see cref="DefaultInstance"/>
        /// property.
        /// </summary>
        /// <param name="getInstance">
        /// A function that returns the value for the <see cref="Current"/> property.
        /// </param>
        public void SetCurrent(Func<T> getInstance)
        {
            _currentInstance =
                getInstance == null
                    ? _defaultInstance
                    : new Lazy<T>(getInstance);
        }

        /// <summary>
        /// Sets the value of the <see cref="Current"/> property. If the
        /// <paramref name="instance"/> parameter is null, sets the value of the
        /// <see cref="Current"/> to the value of the <see cref="DefaultInstance"/>
        /// property.
        /// </summary>
        /// <param name="instance">
        /// The value for the <see cref="Current"/> property.
        /// </param>
        public void SetCurrent(T instance)
        {
            _currentInstance =
                instance == null
                    ? _defaultInstance
                    : new Lazy<T>(() => instance);
        }
    }

    /// <summary>
    /// Provides information about an export.
    /// </summary>
    internal class ExportInfo
    {
        /// <summary>
        /// The default priority for an instance of <see cref="ExportInfo"/> if not specified.
        /// </summary>
        public const int DefaultPriority = -1;

        private readonly Type _targetClass;
        private readonly int _priority;

        /// <summary>
        /// Initializes a new instance of the <see cref="ExportInfo"/> class with
        /// a priority with the value of <see cref="DefaultPriority"/>.
        /// </summary>
        /// <param name="targetClass">The class to be exported.</param>
        public ExportInfo(Type targetClass)
            : this(targetClass, DefaultPriority)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExportInfo"/> class.
        /// </summary>
        /// <param name="targetClass">The class to be exported.</param>
        /// <param name="priority">
        /// The priority of the export, relative to the priority of other exports.
        /// </param>
        public ExportInfo(Type targetClass, int priority)
        {
            if (targetClass == null)
            {
                throw new ArgumentNullException("targetClass");
            }

            if (targetClass.Assembly.ReflectionOnly)
            {
                targetClass = Type.GetType(targetClass.AssemblyQualifiedName);
            }

            _targetClass = targetClass;
            _priority = priority;
        }

        /// <summary>
        /// Gets the class to be exported.
        /// </summary>
        public Type TargetClass { get { return _targetClass; } }

        /// <summary>
        /// Gets the priority of the export, relative to the priority of other exports.
        /// The default value, if not specified in the constructor is negative one.
        /// This value is used during import operations to sort the discovered classes.
        /// </summary>
        public int Priority { get { return _priority; } }

        /// <summary>
        /// Gets or sets the name of the export. This value is compared against the
        /// name parameter in various import operations.
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether the type indicated by
        /// <see cref="TargetClass"/> should be excluded from consideration during an
        /// import operation.
        /// </summary>
        public bool Disabled { get; set; }
    }

    /// <summary>
    /// Defines various options for an import operation.
    /// </summary>
    internal class ImportOptions
    {
        private string[] _directoryPaths = GetDefaultDirectoryPaths();
        private IComparer<ExportInfo> _exportComparer = GetDefaultExportComparer();

        /// <summary>
        /// Gets or sets a value indicating whether to allow non-public classes to be imported.
        /// Default value is false, indicating that only public classes will be included in an
        /// import operation.
        /// </summary>
        public bool AllowNonPublicClasses { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether a named export will be included from an
        /// unnamed import operation. Default value is false, indicating that named exports
        /// will not be used given an unnamed import.
        /// </summary>
        public bool IncludeNamedExportsFromUnnamedImports { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether, given equal priorities, an implementation
        /// of TTargetType will be chosen over an implementation of TFactoryType. Default
        /// value is false, indicating that TFactoryType will be preferred.
        /// </summary>
        public bool PreferTTargetType { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether types that are defined in this assembly
        /// should be considered from an import operation. Default value is false, indicating
        /// that types defined in this assembly will be excluded.
        /// </summary>
        public bool IncludeTypesFromThisAssembly { get; set; }

        /// <summary>
        /// Gets or sets the directory paths that are searched for an import operation. 
        /// If not set, or set to null, the value returned will contain a single element:
        /// the value returned by AppDomain.CurrentDomain.BaseDirectory.
        /// </summary>
        public IEnumerable<string> DirectoryPaths
        {
            get { return _directoryPaths; }
            set
            {
                _directoryPaths =
                    value != null
                        ? value.OrderBy(x => x).ToArray()
                        : GetDefaultDirectoryPaths();
            }
        }

        /// <summary>
        /// Gets or sets a comparer to be used to differentiate between multiple
        /// exports with the same priority. If not set, or set to null, the value
        /// returned will be a comparer that sorts based on the assembly qualified
        /// name of the target class.
        /// </summary>
        public IComparer<ExportInfo> ExportComparer
        {
            get { return _exportComparer; }
            set
            {
                _exportComparer = value ?? GetDefaultExportComparer();
            }
        }

        /// <summary>
        /// Returns an array containing a single element: the value returned by
        /// AppDomain.CurrentDomain.BaseDirectory.
        /// </summary>
        private static string[] GetDefaultDirectoryPaths()
        {
            return new[]
            {
                AppDomain.CurrentDomain.BaseDirectory,
                Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "bin")
            };
        }

        /// <summary>
        /// Gets a new instance of <see cref="TargetClassAssemblyQualifiedNameComparer"/>.
        /// </summary>
        private static IComparer<ExportInfo> GetDefaultExportComparer()
        {
            return new TargetClassAssemblyQualifiedNameComparer();
        }

        private class TargetClassAssemblyQualifiedNameComparer : IComparer<ExportInfo>
        {
            public int Compare(ExportInfo lhs, ExportInfo rhs)
            {
                var lhsString = lhs.TargetClass.AssemblyQualifiedName ?? lhs.TargetClass.ToString();
                var rhsString = rhs.TargetClass.AssemblyQualifiedName ?? rhs.TargetClass.ToString();

                return lhsString.CompareTo(rhsString);
            }
        }
    }
}